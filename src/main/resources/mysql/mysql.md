## MySQL
    多版本并发控制。

+ **MVVC**   
    在InnoDB中，会在每行数据后增加两个额外的隐藏字段来实现MVVC，这两个值一个记录这行数据是何时被创建的，一个记录这行数据何时过期(或者被删除)。
    在时间存储中存储的并不是时间，而是版本号，没开启一个事务，版本号都会递增。   
    在RR隔离级别下：   
    + Select时，读取创建版本号<=当前事务版本号，删除版本号为空或大于当前事务版本号。   
    + INSERT时，保存当前创建版本号为当前事务版本号。   
    + DELETE时，保存当前创建版本号为行删除版本号。   
    + UPDATE时，插入一条新纪录，保存当时事务版本号为行创建版本号，同事保存当前事务版本号到之前删除的行。   
    通过MVCC，虽然每行记录都需要额外的存储空间，更多的行检查工作以及一些额外的维护工作，但可以减少锁的使用，大多数读操作都不用加锁，读数据操作很简单，
    性能很好，并且也能保证只会读取到符合标准的行，也只锁住必要行。   
+ **快照读和当前读**    
    + 快照读(snapshot read)：读取记录可见版本的数据(有可能是历史数据)。在InnoDB下：简单的Select操作,属于快照读 `select * from table ….`;    
        快照读的实现方式为MVVC+undo log 
    + 当前读(current read)：读取当前最新版本数据。特殊的操作，插入/更新/删除操作，属于当前读，需要加锁(使用next-key(行锁+间隙锁)算法实现)   
    `select * from table where ? lock in share mode;
     select * from table where ? for update;
     insert into table values (…);
     update table set ? where ?;
     delete from table where ?;`   
     事务的隔离级别实际上都是定义了当前读的级别，MySQL为了减少锁处理（包括等待其它锁）的时间，提升并发能力，引入了快照读的概念，使得select不用加锁。
     而update、insert这些“当前读”，就需要另外的模块来解决了。        
+   **存储引擎**   
    * InnoDB存储引擎   
        InnoDB现在是MySQL的默认存储引擎，其设计目标主要为在线事务(OLTP)的应用。其特点为**行锁设计**，**支持外键**，支持**非锁定读**即默认读操作不会产生锁。
        InnoDB采用多版本并发控制(MVVC)来获得高并发，并实现了SQL标准的四种隔离级别，默认为RR(可重复读)，并通过间隙锁策略防止幻读出现。   
        InnoDB采用**聚集索引**的方式，因此每张表的存储方式都是按照主键的顺序进行存放的。如果没有指定主键，InnoDB会生成一个6为的ROWID作为主键。数据和主索引
            放在一起，在b+树的叶子节点上。辅助索引叶子节点存储的为对应数据主索引的键。      
    * MyISAM存储引擎   
        MyISAM**不支持事务**，锁粒度为**表锁**，**支持全文索引**，主要面向一下在线分析(OLAP)应用。查询和插入效率较高。       
        MyISAM的缓冲池只缓冲索引文件，而不缓冲数据文件。MyISAM的数据存储在两个文件中:数据文件(以.MYD)和索引文件(.MYI)为扩展名。   
        MyISAM表可以存储行记录数，一般受限于可用的磁盘空间，或者操作系统中单个文件的最大尺寸。   
        MyISAM可以使用myisampack对MyISAM表进行压缩，压缩表是**不能修改的**,试用与创建数据后，不再进行修改的数据。压缩表可以极大的减少磁盘空间
            因此可以减少IO，从而提升查询性能。压缩包也只支持索引，但索引也是只读的。   
        MyISAM使用B+树作为索引算法，叶子节点不存数据，存储的是数据的数据记录的地址。主索引和辅助索引类似，主索引要求key唯一，辅助索引不要求。      
    * NDB存储引擎   
        NDB是一个集群存储引擎。   
    * Memory存储引擎       
        Memory存储引擎将表数据存放在内存中，如果数据库重启或者发送崩溃，表中的数据都将消失。适合作为临时时间的临时表。   
        Memory存储引擎默认采用hash索引。    
    * Archive存储引擎   
        Archive只支持select和insert。在5.1版本之后支持索引。   
        Archive使用zlib算法将数据进行压缩后进行存储。压缩比可达1：10，所以磁盘IO更小。但是每次select都需要进行全表扫描。   
        Archive适合日志和数据采集类应用或归档数据。       
+ **索引**   
    * B树/B+树索引   
    B+树是为磁盘为其他直接存取辅助设备设计出的一种平衡二叉树。在B+树中，所有记录节点都是按键值大小顺序存放在同一层叶子节点上，由个叶子节点指针进行链接。   
    ![avatar](https://github.com/NPFDamon/Study/blob/main/src/main/resources/mysql/b+.jpeg)   
    浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，
    P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不存储真实的数据，
    只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。   
    查找过程：如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，
    内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，
    通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，
    性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。   
    + 特点：   
       1.IO此时取决于b+树的高度h，假设当前数据库表数据为N，每个磁盘块数据项的数量为M，则h=log(m+1)n,当数据量一样的情况下，m越小，h越大，而
       m=磁盘块的大小 / 数据量的大小，磁盘块的大小也就是一个数据页的大小，这个大小是固定的；如果数据项占的空间越小，数据项的数量越多，树的高度就越低。
       这就是每个数据项，**即索引字段大小要尽量的小**。比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，
       一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。   
       2.当b+树的数据是混合数据的时候，比如(name,age,sex)的时候，b+树是按照从左到右的顺序来建立搜索树的。比如当(张三,20,F)这样的数据来检索的时候，
       b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，
       b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，
       b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的**最左匹配**特性。   
       3.可以把部分数据加载到内存中，减少磁盘操作。    
    + B+树索引分类   
        + 聚集索引   
            InnoDB存储引擎表是索引组织表，即表中的数据按照主键属性存放。聚集索引就是按照每张表的主键构造一个B+树，同时叶子节点中存放的即为整张表的行记录数据，
            也将聚集索引的叶子节点成为数据页。聚集索引的这个特性决定了索引组织表中的数据也是索引的一部分。同b+树一样，每个数据页都通过一个双向链表来进行链接。
            由于实际的数据页只能按照一个b+树进行排序，一张表只有一个聚集索引。由于叶子节点上能直接找到数据，查询优化器更倾向于使用聚集索引。此外，由于定义了
            数据的逻辑顺序，聚集索引能快速的针对范围查询。      
        + 非聚集索引(辅助索引)   
            叶子节点并不包含行记录的所有数据。叶子节点除了包含键值以外，还包含了一个书签(bookmark)。该书签告诉InnoDB存储引擎可以在那儿找到对应的行数据。
            由于InnoDB存储引擎表是索引组织表，因此InnoDB存储引擎的辅助索引的书签就是对应行数据聚集索引的键。辅助索引查找过程：先在辅助索引树中查找数据，
            得到指定主键的值，在对聚集索引进行查找，找到对应的键值，需进行辅助索引和聚集索引IO。   
    * hash索引   
    哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎会对索引的索引列计算一个哈希码(hash code)。在MySQL中只有Memory存储引擎
    支持哈希索引。因为索引本身只存储对应的哈希值,索引的结构十分紧凑，这也让哈希索引的查询速度非常快。   
    哈希索引限制：   
    无法用于排序   
    不支持部分部分索引列匹配查找   
    只支持等值比较，不支持范围查找    
    哈希冲突带来的维护成本很大   
    * 全文索引   
    全文索引是一种特殊类型的索引,他查找的是文本的关键词，而不是直接比较文本中的值。  
    *  前缀索引   
     前缀索引是基于原始索引字段，截取前面指定的字符个数或者字节数来做索引。MySQL 基本上大部分存储引擎都支持前缀索引，目前只有字符类型或者二进制类型的字段可以建立前缀索引。
     比如：CHAR/VARCHAR、TEXT/BLOB、BINARY/VARBINARY。   
     
    **索引的好处**   
    由于磁盘的IO是非常费时且代价昂贵的，计算机会对IO做相应的优化，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内。使用索引可以减少IO操作。   
    可以帮助服务避免排序和临时表。   
    索引可以将随机访问IO变成顺序IO。   
    索引大大减少了数据扫描的数据量。   
+ [**慢查询优化**](https://tech.meituan.com/2014/06/30/mysql-index.html)       
    * 建索引的原则   
    1，最左匹配原则，MySQL会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配。比如a = 1 and b = 2 and c > 3 and d = 4 
    如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。   
    2，=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。   
    3，尽量选择区分度高的列建立索引。区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，
    唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，
    一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。   
    4，索引不能参与计算。比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，
    但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。   
    5，尽量扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。每次新建索引都会新增一个b+树，索引太多
    同样会影响数据库性能。   
    
+ 分库分表   
    分库和分表都有两种分割方式水平切分和垂直切分。   
    1，分表        
        * 垂直分表   
        表中的字段较多，一般将不常用的，数据较大，长度较长的字段拆分到扩展表里。垂直切分是列多的情况下。   
        * 水平切分   
        单表数据量较大。按照某种规则(range，hash取模等)，切分到多张表里。但是这些表还是在同一个库中，所以库级别的数据库操作还是有IO瓶颈的。
        这种情况是不建议使用的，因为数据量是逐渐增加的，当数据量增加到一定的程度还需要再进行切分。比较麻烦。   
    2，分库   
        * 垂直分库   
        一个数据库的表太多。此时就会按照一定的业务逻辑进行垂直切。比如用户相关的表放在一个数据库里，订单相关的表放在一个数据库里。不同的数据库应放到
        不同的服务器上，此时磁盘空间、内存、TPS等等都会得到解决。     
        * 水平分库   
        水平分库理论上切分是比较麻烦的，指将单表的数据切分到不同的服务器上，每个服务器具有相应的库与表，只是表中的数据集不同。水平分库能有效缓解单机和
        单库的性能瓶颈和压力，突破IO、连接数、硬件资源等的瓶颈。   
    分库分表之后的问题   
    1，联合查询困难   
    联合查询不仅困难，而且可以说是不可能，因为两个相关联的表可能会分布在不同的数据库，不同的服务器中。   
    2，事务问题   
    分库分表之后需要支持分布式事务。数据库本身支持的事务管理功能，在分库分表之后就不适用了。如果我们自己编程协调事务，代码方面就又开始了麻烦。   
    3，跨库join困难   
    分库分表后表之间的关联操作将受到限制，我们无法join位于不同分库的表，也无法join分表粒度不同的表， 结果原本一次查询能够完成的业务，可能需要多次查询才能完成。 
    我们可以使用全局表，所有库都拷贝一份。   
    4、结果合并麻烦   
    比如我们购买了商品，订单表可能进行了拆分等等，此时结果合并就比较困难。   
    [可用中间件](https://www.jianshu.com/p/92a565a8eb37)   
    Sharding-JDBC等

    
            
    
  
       