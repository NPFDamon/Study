## MySql 事务
    事务是访问并更新数据库中各种数据项的一个程序执行单元。在事务中的操作要么全部执行，要不都什么都不做。
+ **事务特性**   
    + A-Atomicity(原子性)：原子性指整个数据库事务是不可分割的工作单位。只有使事务中所有的数据库操作都执行成功，才算整个事务成功。事务中的任务一个SQL语句
                         执行失败，已执行的成功的Sql语句也必须撤销,数据库状态应回退到事务执行之前的状态。   
    + C-Consistency(一致性)：事务将数据库从一种状态转换为下一种一致的状态。在事务开始之前和结束之后，数据库的完整性约束没有被破坏。      
    + I-Isolation(隔离性)：隔离性还有其他称呼，如并发控制，可串行化，锁等。事务的隔离性要求每个事务操作的对象对其他事务操作对象能相互分离，即事务提交前
                          对其他事务不可见。   
    + D-Durability(持久性)：事务一旦提交，其结果是永久性的。一旦事务提交，其所做的修改将永久保存到数据库里，即使系统崩溃，数据也不会被修改。   
    
+ **事务的实现**   
    事务的隔离性由锁来实现，原子性，一致性和持久性由数据库的redo log，undo log来实现。redo log为重做日志，用来保证事务的原子性和持久性。undo log
    用来保证事务的一致性。undo和redo都是一种恢复的过程，redo恢复提交事务修改的页操作，而undo回滚行记录到某个版本。两者记录的内容不同，redo通常是
    物理日志，记录的是物理修改操作。undo是逻辑日志，根据每行记录进行记录。   
    
    + redo   
    重做日志用来实现事务的持久性，其中由两部分组成：一是内存中的重做日志缓存(redo log buffer),是易丢失的；二是重做日志文件(redo log file)，是持久性的。   
    InnoDB是事务的存储引擎，其通过Force at Commit机制实现事务的持久性，即当事务提交时，必须先将该事务的所有日志写入到重做日志文件进行持久化，待事务
    的Commit操作完成才算完成。为了确保每次日志都写入重做日志文件，在每次将重做日志缓存写入到重做日志文件后，InnoDB存储引擎都会执行一次fsync(将内核文件
    系统缓存区的所有数据写如存储介质)操作。由于fsync的效率取决于磁盘的性能，*因此磁盘的性能决定了事务提交的性能，也就是数据库的性能*。Mysql允许用户
    手工设置非持久话的情况，即当事务提交时，日志不写入重做文件，而是等一个周期后再执行fsync操作。能显著提高性能，但是出现宕机后会出现数据丢失问题。   
    
    innodb_flush_log_at_trx_commit用来控制重做日志刷新磁盘策略。该参数默认值为1，表示每次提交时必须进行fsync操作。还可以设置0和2，0表示提交时
    不进行写入重做日志操作，这个操作仅在master thread中完成，而master thread每1秒会进行一fsync操作。2表示提交时仅写入重做日志缓存中，不进行fsync操作
    这个设置下宕机会发生数据丢失。   
    + undo   
    重做日志记录了事务的行为，可以很好的通过其对页进行"重做"操作，但是事务有时候需要回滚，这时候就需要undo。undo存放在数据库内部的一个特殊段(segment)中，
    这个段成为undo段(undo segment)。undo段位于共享表空间内。undo是逻辑日志，只是将数据逻辑的恢复到原来的样子。所有的修改都被取消了，但是数据结构和页本身
    在回滚之后可能大不相同。     
    undo的两个作用，一个为数据回滚，另一个是MVCC   
    undo回滚时会对每个操作存储一个相反的操作，对于每个insert，InnoDB会完成一个delete，对于delete，会完成一个insert，对于每个UPDATE，会执行一个相反的UPDATE，将修改前的行放回去。   
    对于MVCC，当用户读取一条记录时，若该记录被一个事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读。   
+ **事务隔离级别**    
    * Read Uncommitted:未提交读。又称浏览访问，所有的访问都可以看到其他事务未提交的数据。会引发**脏读**问题。   
    * Read Committed:读已提交。一个事务能读取已提交的数据。会引发**不可重复读**问题。    
    * Repeatable Read:可重复读。MySQL默认隔离级别。[**解决了幻读**问题？。(众说纷纭)](https://github.com/Yhzhtk/note/issues/42)   
    * Serializable:串行化。在此隔离级别下InnoDB存储引擎会在每个select语句后自动加上lock in share mode，即为每个读加上一个共享锁。读写都活阻塞，不会出现任何问题。      
   【不可重复读为多次查询同一条数据出现数据不一样的情况；幻读为多次查询一个范围内的数据出现数据条数不一样的情况】   
   【幻读问题】 > https://www.zhihu.com/question/47007926,https://tech.meituan.com/2014/08/20/innodb-lock.html   
+ **快照读和当前读**    
    + 快照读(snapshot read)：读取记录可见版本的数据(有可能是历史数据)。在InnoDB下：简单的Select操作,属于快照读 `select * from table ….`;     
    + 当前读(current read)：读取当前最新版本数据。特殊的操作，插入/更新/删除操作，属于当前读，需要加锁   
    `select * from table where ? lock in share mode;
     select * from table where ? for update;
     insert into table values (…);
     update table set ? where ?;
     delete from table where ?;`   
     事务的隔离级别实际上都是定义了当前读的级别，MySQL为了减少锁处理（包括等待其它锁）的时间，提升并发能力，引入了快照读的概念，使得select不用加锁。
     而update、insert这些“当前读”，就需要另外的模块来解决了。   
     
   
     
   