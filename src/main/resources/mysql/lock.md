## Mysql Lock 
 
+ **MySQL锁**   
    MyISAM引擎只支持表锁，每次都是锁整张表；InnoDB不仅支持表锁，还支持更加细粒度的行锁，所以InnoDB的性能更高。   
    无论行锁还是表锁，MySQL的锁分为两类：   
    + S锁(shared(S) locks)，称为共享锁，运行事务读取一条数据。事务读取记录的时候获取S锁，运行多个事务获取S锁，相互之间不会影响。   
    + X锁(exclusive(X) locks)，称为独占锁，运行事务更新或删除一条数据。事务写入记录的时候获取X锁，且只允许一个事务获取X锁，其他事务需要阻塞等待。   
    X锁与任何锁都不兼容，而S锁仅和S锁兼容。S锁和X锁都是行锁。   
    
    |   冲突    |   S    |  X     |    
    |   ---    |  ---   |  ---   |     
    |    S     | 不冲突  |  冲突  |    
    |    X     |  冲突   |  冲突  |    
    
    普通的Select查询时不加锁的，而`select ... lock in share mode`这种读取需要加上S锁，`select ... for update`需要加上X锁。   
    InnoDB表锁：  
    `Lock tables xxx read`对xxx表加上S锁。   
    `Lock tables xxx write`对xxx表加上X锁。   
    InnoDB表锁很鸡肋，update 、select 要用的就是行锁，不可能用粒度更粗的表锁。唯一用到表锁的是DDL语句,比如alter table xxx 的时候，这个时候应该
    锁整张表，防止查询和修改，但是MySQL已经提供了MDL(Metadata locks)用来阻塞。表锁就排不上用场了。（当恢复数据的时候，手动锁表还原数据的时候，应该应道表锁）   
    除此之外，InnoDB存储引擎支持多粒度锁定，这种锁定运行事务在*表级上的锁*和*行级上的锁*同时存在。为了支持在不同粒度上进行加锁操作，InnoDB支持一种
    额外的锁定方式，成为意向锁。**意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁。**   
    意向锁：   
    + 意向共享锁(IS lock)：事务想要获取一张表中某几行的共享锁。   
    + 意向排它锁(IX lock)：事务想要获取一张表中的几行排它锁。   
    意向锁是*表级别的锁*,当需要对表中的某条记录加S锁的时候,现在这个表上加IS锁,表明此时表内有S锁。当需要对表内的对象加X锁时，先在表上加IX锁,表明此时
    表内有X锁。这样操作之后，如果需要加表锁，就不需要遍历所有的记录去找行锁了，自己看表上是否有IS 和 IX锁就行了。   
    
    |兼容性 |IS   |IS   |   IX   |   S    |    X   |
    |IS |兼容   |兼容   |   兼容   |   兼容    |    不兼容   |   
    |IX |兼容   |不兼容   |   兼容   |   不兼容    |    不兼容   |   
    |S |兼容   |兼容   |  不兼容   |   兼容    |    不兼容   |   
    |X |不兼容   |不兼容   |   不兼容   |   不兼容    |    不兼容   |   
  