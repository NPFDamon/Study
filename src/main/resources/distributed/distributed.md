## 分布式相关
+ CAP理论   
    一个分布式系统最多只能同事满足一致性(Consistency)-C,可用性(Availability)-A和分区容错性(Partition tolerance)中三项中的两项。   
    ![avatar](https://github.com/NPFDamon/Study/blob/main/src/main/resources/distributed/cap.jpeg)     
    
    * Consistency 一致性   
        一致性指`all nodes see the same data at the same time`，即所有节点在同一时间的数据完全一致。   
        对于一致性又可分为强/弱/最终一致性三类。   
        + 强一致性：要求更新过的数据都能被后续的访问看到，这就是强一致性。   
        + 若一致性：能容忍后续的部分数据或者全部数据访问不到，就是若一致性。   
        + 最终一致性：如果经过一段时间后能看到更新后的数据，就是最终一致性。   
    * Availability 可用性      
        可用性指`Reads and writes always succeed`，即服务在正常相应时间能一直可用。   
    * Partition Tolerance 分区容错性   
        分区容错性指`the system continues to operate despite arbitrary message loss or failure of part of the system`，即分布式系统
        某个节点或网络分区遇到故障的时候，仍然可用提供一致性或可用性的服务。   
        
    在CAP中有三种选择：   
    1，CA:放弃分区容错性，来达到可用性和一致性。把所有和事务相关的内容都放到一台机器上，避免网络分区。这样根不存在网络分区的情况。(不再是分布式系统)
    2，AP:放弃一致性，来成就可用性和分区容错性。可以及时获取数据，但是数据可能是不一致的。即使是不一致的，也有马上获取这个数据。(Zookeeper,Nacos)   
    3，CP:放弃可用性，来成就一致性和分区容错性。当出现网络分区时，需要等数据一致后再去获取数据，此时短时间内无法获取数据，失去可用性。(Eureka,Nacos)   
    在分布式系统中P是客观存在的，不选P，一旦发生错误，整个系统都不可用了，这不符合实际需求。所以只能从C和A中选择一个。   
    对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到N个9，即保证P和A，
    舍弃C（退而求其次保证最终一致性）。虽然某些地方会影响客户体验，但没达到造成用户流程的严重程度。   
   
    对于涉及到钱财这样不能有一丝让步的场景，C必须保证。网络发生故障宁可停止服务，这是保证CA，舍弃P。还有一种是保证CP，舍弃A。例如网络故障事只读不写。
    
+ BASE和最终一致性   
    BASE是`Basically Available Soft Sate和Eventual consistency`的简写，意思是“碱”。
    ACID是关系数据库中的事务的四个性质。在NoSQL数据库中BASE（碱）和ACID（酸）是对应的。   
    在关系型数据量追求的是ACID的一致性，而在NoSQL数据库中追求的是BASE特性。   
    BASE的核心思想是即使无法做到强一致性,但是每个应用可以根据自己的业务特点，采用适当的方式达到最终一致性。`也就是牺牲数据的一致性来满足系统的高可用性，
    系统中一部分数据不可用或不一致时，仍需要保持系统的"主要可用
    
    BASE特性： 
    * 基本可用(Basically Available)   
        值一个分布式系统的一部分变得不可用时，其他部分仍能正常使用，也就是允许分区失败的出现。例如：一个数据库系统部署了很多节点，有可能一两个节点出现了失败，但是整个系统依然是可用的。   
    * 软状态(Soft State)    
        与硬状态相对应，指状态可以有一段时间不同步，具有不同步的时间窗口，具有一定的滞后性。 
        硬状态，数据库数据必须一致保证数据库状态的一致性，指任意时刻的数据都是正确的。     
    * 最终一致性(Eventual Consistency)   
       最终一致性为弱一致性的一种特例，如果经过一段时间后能看到更新后的数据，就是最终一致性。根据数据更新后进程访问时间的**时间**和**方式**的不同可以区分为：   
       1，因果一致性：如果进程A通知进程B它已经更新了一个数据项，那么进程B的后续访问将获取进程A的最新值。比如，我通知你，你就能获取后面的更新值，其他进程C、D，
       我没有通知到你，你就访问不到我刚刚写的值，只能最终能访问到，不是马上就访问到。   
       2，读自己所写：当进程A执行一个更新操作后，它自己总是能够访问最新值，不会读到旧值。   
       3，单调读一致性：如果进程已经看到过数据对象的某个值，那么任何后续访问都不会返回之前的旧值。   
       4，会话一致性：把访问存储系统的过程，放到会话上下文进程中，这个时候只要这些会话存在，系统就可以保证"读自己之所写一致性"。   
       5，单调写一致性：系统需保证来着同一进程的写操作是按照顺序执行的。同一个进程可能发生多个写操作，写操作有先有后，系统必须保证这些写操作按照顺序执行。   
          
    
    
    
    